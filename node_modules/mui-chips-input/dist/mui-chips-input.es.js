import C from "react";
import Q from "@mui/material/Chip";
import { styled as B } from "@mui/material/styles";
import { jsx as m } from "react/jsx-runtime";
import me from "@mui/icons-material/Close";
import xe from "@mui/material/ClickAwayListener";
import ge from "@mui/material/IconButton";
import ye from "@mui/material/TextField";
const O = {
  enter: "Enter",
  backspace: "Backspace"
}, be = {
  ime: 229
}, De = B(Q)(({ theme: t, size: n }) => `
    max-width: 100%;
    margin: 2px 4px;
    height: ${n === "small" ? "26px" : "32px"};


    &[aria-disabled="true"] > svg {
      color: ${t.palette.action.disabled};
      cursor: default;
    }

    &.MuiChipsInput-Chip-Editing {
      background-color: ${t.palette.primary.light};
      color: ${t.palette.primary.contrastText};
    }
  `), Ee = {
  ChipStyled: De
}, H = (t) => {
  const {
    className: n,
    index: i,
    onDelete: r,
    disabled: a,
    onEdit: g,
    isEditing: E,
    disableEdition: c,
    ...y
  } = t, u = (s) => {
    s.key === O.enter && r(i);
  }, A = (s) => {
    s?.preventDefault?.(), s?.stopPropagation?.(), r(i);
  }, b = (s) => {
    s.target.textContent === y.label && (a || g(i));
  };
  return /* @__PURE__ */ m(Ee.ChipStyled, {
    className: `MuiChipsInput-Chip ${E ? "MuiChipsInput-Chip-Editing" : ""} ${n || ""}`,
    onKeyDown: u,
    disabled: a,
    onDoubleClick: c ? void 0 : b,
    tabIndex: a ? -1 : 0,
    "aria-disabled": a,
    onDelete: A,
    ...y
  });
};
function Ae(t) {
  return typeof t == "boolean";
}
function Ie(t) {
  return typeof t == "object" && !Array.isArray(t) && t !== null;
}
function we(t, n) {
  typeof n == "function" ? n(t) : n && Ie(n) && "current" in n && (n.current = t);
}
const ke = B("div")`
  top: 50%;
  transform: translateY(-50%);
  right: 10px;
  position: absolute;
`, Oe = B(ye)((t) => `
    max-width: 100%;

    .MuiInputBase-root {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      row-gap: 5px;
      padding-top: ${t.size === "small" ? "5px" : "9px"};
      padding-right: ${t.InputProps?.endAdornment ? "30px" : "9px"};
      padding-bottom: ${t.size === "small" ? "5px" : "9px"};
      padding-left: 10px;

      input {
        min-width: 30px;
        width: auto;
        flex-grow: 1;
        text-overflow: ellipsis;
        padding: ${t.size === "small" ? "3.5px 4px" : "7.5px 4px"};
        align-self: center;
      }
    }
  `), Te = B(Q)(({ theme: t, size: n }) => `
    max-width: 100%;
    margin: 2px 4px;
    height: ${n === "small" ? "26px" : "32px"};

    &[aria-disabled="true"] > svg.MuiChip-deleteIcon {
      color: ${t.palette.action.disabled};
      cursor: default;
    }
  `), J = {
  ChipStyled: Te,
  TextFieldStyled: Oe,
  EndAdornmentClose: ke
}, X = C.forwardRef((t, n) => {
  const {
    chips: i,
    onAddChip: r,
    onEditChip: a,
    onDeleteChip: g,
    onDeleteAllChips: E,
    InputProps: c,
    onInputChange: y,
    disabled: u,
    clearInputOnBlur: A,
    validate: b,
    error: s,
    helperText: T,
    hideClearAll: I,
    inputProps: P,
    size: $,
    disableDeleteOnBackspace: K,
    disableEdition: V,
    className: M,
    renderChip: v,
    addOnWhichKey: w,
    onFocus: o,
    inputValue: d,
    ...S
  } = t, [Z, ee] = C.useState(""), [z, Y] = C.useState(""), N = C.useRef(null), F = C.useRef(!1), te = C.useRef(typeof d == "string"), [x, W] = C.useState(null), {
    onKeyDown: ne,
    ...ie
  } = P || {}, {
    inputRef: ve,
    ...le
  } = c || {}, j = () => {
    Y("");
  }, _ = te.current, k = _ ? d : Z, R = (e) => {
    y?.(e), _ || ee(e);
  }, re = (e) => {
    R(i[e]), W(e), j();
  }, D = () => {
    W(null);
  }, h = () => {
    j(), R("");
  }, oe = (e) => {
    R(e.target.value);
  }, L = () => {
    !F.current || (x !== null ? (D(), h()) : A && h(), F.current = !1);
  }, ae = (e) => {
    N.current = e, n && we(e, n);
  }, U = (e, l) => (p) => {
    if (typeof b == "function") {
      const f = b(e);
      if (f === !1) {
        l.preventDefault();
        return;
      }
      if (!Ae(f) && f.isError) {
        l.preventDefault(), Y(f.textError);
        return;
      }
    }
    p();
  }, se = (e, l, p) => {
    U(e, p)(() => {
      a?.(e, l), D(), h();
    });
  }, de = (e, l) => {
    U(e, l)(() => {
      r?.(k.trim()), h();
    });
  }, pe = (e, l) => l === be.ime ? !1 : w ? Array.isArray(w) ? w.some((p) => p === e) : w === e : e === O.enter, ue = (e) => {
    const l = pe(e.key, e.keyCode), p = e.key === O.backspace, f = k.trim();
    if (e.code === "Tab") {
      L();
      return;
    }
    if (l && e.preventDefault(), k.length > 0 && l)
      f.length === 0 ? h() : x !== null ? se(f, x, e) : de(f, e);
    else if (p && k.length === 0 && i.length > 0 && !K) {
      const q = i.length - 1;
      g?.(q), x === q && D();
    }
    ne?.(e);
  }, ce = (e) => {
    e.preventDefault(), o?.(e), F.current = !0;
  }, he = (e) => {
    e.preventDefault(), !I && !u && (E?.(), h(), D());
  }, fe = (e) => {
    e === x ? (h(), D()) : re(e), N.current?.focus();
  }, Ce = (e) => {
    u || (g?.(e), x !== null && (D(), h()));
  }, G = i.length > 0;
  return /* @__PURE__ */ m(xe, {
    onClickAway: L,
    children: /* @__PURE__ */ m(J.TextFieldStyled, {
      value: k,
      onChange: oe,
      ref: n,
      className: `MuiChipsInput-TextField ${M || ""}`,
      size: $,
      placeholder: "Type and press enter",
      onFocus: ce,
      inputProps: {
        onKeyDown: ue,
        ...ie
      },
      disabled: u,
      error: Boolean(z) || s,
      helperText: z || T,
      InputProps: {
        inputRef: ae,
        startAdornment: G ? i.map((e, l) => {
          const p = {
            key: `chip-${l}`,
            index: l,
            onEdit: fe,
            label: e,
            title: e,
            isEditing: l === x,
            size: $,
            disabled: u,
            disableEdition: V,
            onDelete: Ce
          };
          return v ? v(H, p) : /* @__PURE__ */ m(H, {
            ...p
          });
        }) : null,
        endAdornment: I ? null : /* @__PURE__ */ m(J.EndAdornmentClose, {
          style: {
            visibility: G ? "visible" : "hidden"
          },
          children: /* @__PURE__ */ m(ge, {
            "aria-label": "Clear",
            title: "Clear",
            disabled: u,
            size: "small",
            onClick: he,
            children: /* @__PURE__ */ m(me, {
              fontSize: "small"
            })
          })
        }),
        ...le
      },
      ...S
    })
  });
});
X.defaultProps = {
  onInputChange: () => {
  },
  clearInputOnBlur: !1,
  hideClearAll: !1,
  disableDeleteOnBackspace: !1,
  disableEdition: !1,
  addOnWhichKey: O.enter,
  onDeleteChip: () => {
  },
  onAddChip: () => {
  },
  inputValue: void 0,
  onEditChip: () => {
  },
  renderChip: void 0,
  onDeleteAllChips: () => {
  },
  validate: () => !0
};
function $e(t, n) {
  return [...t, n];
}
function Be(t, n) {
  return t.filter((i, r) => n !== r);
}
function Pe(t, n, i) {
  return t.map((r, a) => n === a ? i : r);
}
const Ke = C.forwardRef((t, n) => {
  const {
    value: i,
    onChange: r,
    onAddChip: a,
    onInputChange: g,
    onDeleteChip: E,
    disabled: c,
    validate: y,
    clearInputOnBlur: u,
    hideClearAll: A,
    disableDeleteOnBackspace: b,
    onEditChip: s,
    renderChip: T,
    disableEdition: I,
    addOnWhichKey: P,
    inputValue: $,
    ...K
  } = t;
  return /* @__PURE__ */ m(X, {
    chips: i,
    onAddChip: (o) => {
      if (c)
        return;
      const d = $e(i, o), S = d.length - 1;
      a?.(o, S), r?.(d);
    },
    onInputChange: g,
    disableDeleteOnBackspace: b,
    onDeleteChip: (o) => {
      if (c)
        return;
      const d = i[o];
      r?.(Be(i, o)), E?.(d, o);
    },
    onEditChip: (o, d) => {
      c || I || (r?.(Pe(i, d, o)), s?.(o, d));
    },
    renderChip: T,
    onDeleteAllChips: () => {
      r?.([]);
    },
    clearInputOnBlur: u,
    disabled: c,
    disableEdition: I,
    validate: y,
    inputValue: $,
    hideClearAll: A,
    addOnWhichKey: P,
    ...K,
    ref: n
  });
});
Ke.defaultProps = {
  value: [],
  onChange: () => {
  },
  onAddChip: () => {
  },
  onDeleteChip: () => {
  },
  onInputChange: () => {
  },
  onEditChip: () => {
  },
  addOnWhichKey: O.enter,
  clearInputOnBlur: !1,
  disableEdition: !1,
  hideClearAll: !1,
  disableDeleteOnBackspace: !1,
  validate: () => !0
};
export {
  Ke as MuiChipsInput
};
